# -*- coding: UTF-8 -*-
import numpy as np
import pandas as pd
import math
import matplotlib.pyplot as plt
import fastdtw as dtw
import datetime
import glob
from dateutil.relativedelta import relativedelta 

import csv

''' ==============================================================================='''
''' ================ S E C T I O N:   D A T A   R E A D I N G  ===================='''
''' ==============================================================================='''
def read_NDVI(mun_num, clust_cut_val):
    '''
    Read the NDVI pickles. The ones already generated by the "modis-luigi.py" pipeline
    INPUT:
        - mun_num: (int) municipality number 
            (TO_DO: mun_num does not include the whole number. La cve_ent tiene que ser incorporada, para buscar municipios dentro de estados.... ahora es solo de "jugete")
        - clust_cut_val: (int) desired clusterization cut-value, i.e., the cut-value parameter the clusters were created with in the "modis-luigi.py" pipeline
    
    OUTPUT:
        - cve_mun: (str) Municipality number (including the cve_ent)
        - im: (3-dimensional np.ndarray of 'int16') Time Series of the NDVI values in the municipality.
        - clust: (2-dimensional np.ndarray of 'int16') Value of the cluster each pixel in the municipality belong to.
        - init_date:(datetime.date) Date of first observation in the series im
        - end_date: (datetime.date) Date of last observation in the series im
    '''
    path = './arrays/*.p'
    tss = glob.glob(path)
    path2 = './clusters/*.p'
    clusts = glob.glob(path2)
     
    i = mun_num
    corte = clust_cut_val
    im = pd.read_pickle(tss[i]) # read the municipality NDVI/EVI time series values
    clust = pd.read_pickle(clusts[(i*5 + corte)]).astype('int16') # read the cluster "map"
    cve_mpo = tss[i][(tss[i].find('\\')+1):tss[i].find('_')]
    init_date = [int(x) for x in (tss[i][(1+tss[i].find('_')):tss[i].find('-')]).split(sep = '.') ]
    init_date = datetime.date(init_date[0], init_date[1], init_date[2])
    end_date = [int(x) for x in (tss[i][(1+tss[i].find('-')):-2]).split(sep='.')]
    end_date = datetime.date(end_date[0], end_date[1], end_date[2])
    return(cve_mpo, im, clust, init_date, end_date)


def read_agricolaDB(cve_mpo, init_date, end_date):
    '''
    load the database that contains the objective value 
        y=superficie_Cosechada/superficie_Sembrada
    INPUT:
        - init_date:(datetime.date) Date of NDVI´s Time Series first observation
        - end_date: (datetime.date) Date of NDVI´s Time Series last observation
    OUTPUT:
        y_TPV: (DataFrame) 'temporal' & 'primavera-verano' y_variable, indexed over the dates
        y_RPV: (DataFrame) 'riego' & 'primavera-verano' y_variable, indexed over the dates
        y_TOI: (DataFrame) 'temporal' & 'otono-invierno' y_variable, indexed over the dates
        y_ROI: (DataFrame) 'temporal' & 'otono-invierno' y_variable, indexed over the dates
    '''
    path_y = './avance_agricola/agricola_201712.csv'
    with open(path_y,'r') as f:
        reader = csv.reader(f, skipinitialspace=False)
        colnames = np.array(next(reader))
        db1 = np.array([(x) for x in reader if x[1] == cve_mpo]) # only interested on the municipality (i+1)
    '''
    NOT SURE OF THIS ANYMORE:
    # the y variable ig going to be 4-months lagged
    init_date += relativedelta(months = 4)
    end_date  += relativedelta(months = 4) 
    '''
    df = pd.DataFrame(db1, columns = colnames, dtype = str ) # see values EXAMPLE: df.loc[1,:]
    '''PREPROCESS observed y_ variable'''
    # transform desired variables from strings to floats
    numeric_vars = ['mes','anio','sup_sembrada', 'sup_cosechada', 'sup_siniestrada',
                'produccion', 'rendimiento', 'mes_agricola', 'anio_agricola']
    for var in numeric_vars:
        df[var] = df[var].map(lambda x: x.replace(',',''))

    df[numeric_vars] = df[numeric_vars].apply(pd.to_numeric)


    #df[(df['sup_sembrada'] == df['sup_cosechada'] + df['sup_siniestrada'])]
    df['date'] = [datetime.datetime(x,y,1) for x,y in zip(df['anio'],df['mes'])] 
    df['date_agricola'] = [datetime.datetime(x,y,1) for x,y in zip(df['anio_agricola'],df['mes_agricola'])] 

    # choose only the dates we are interested in (i.e., the ones for which we have the ndvi TS)
    df = df.loc[(df['date'] >= init_date) & (df['date'] <= end_date)]

    # sort in ascending date values
    df = df.sort_values(by = 'date', ascending = True)

    # generate observed value harvested_surface/planted_surface
    df['prop_cosecha'] = df['sup_cosechada']/df['sup_sembrada']
    
    # divide y variable by agricultural cycle ("ciclo") and watering method ("modalidad hidrica")
    y_TPV = df.loc[(df['moda_hidr'] == 'T') & (df['ciclo'] == 'PV')][['date','prop_cosecha']]
    y_RPV = df.loc[(df['moda_hidr'] == 'R') & (df['ciclo'] == 'PV')][['date','prop_cosecha']]
    y_TOI = df.loc[(df['moda_hidr'] == 'T') & (df['ciclo'] == 'OI')][['date','prop_cosecha']]
    y_ROI = df.loc[(df['moda_hidr'] == 'R') & (df['ciclo'] == 'OI')][['date','prop_cosecha']]
    return (y_TPV.set_index('date'),
            y_RPV.set_index('date'),
            y_TOI.set_index('date'),
            y_ROI.set_index('date'))

''' ------------------------------------------------------------------------------'''






''' ==============================================================================='''
''' ========== S E C T I O N:   V I S U A L I Z A T I O N   T O O L S ============='''
''' ==============================================================================='''

def gridPlotsTS(im, mpo):
    '''
    #=============================================================
    # function to vizualize the TS of a municilpality 
    #
    # INPUT:
        - im := a 3-dim array with the values of the EVI TS
                (x,y,z) := value of the EVI in "coords" (x,y) at time step z
        - mpo := clave del municipio
    #=============================================================
    '''
    plt.figure()
    gridsize = math.ceil(math.sqrt(im.shape[2]))
    for t in range(0,(im.shape[2])):
        image = im[:,:,t]
        pl = plt.subplot(gridsize, gridsize, t+1)
        pl = plt.imshow(image, aspect='auto')
        pl.axes.get_xaxis().set_ticks([])
        pl.axes.get_yaxis().set_ticks([])
        if t ==  math.ceil(gridsize/2):
            plt.title("Serie de Tiempo del NDVI del municipio "+mpo)
    plt.show()
    
''' ------------------------------------------------------------------------------'''



''' ==============================================================================='''
''' ================ S E C T I O N:   P R E P R O C E S S ========================='''
''' ==============================================================================='''

def perdelta(start, end, delta):
    curr = np.array(start)
    array = np.array(start)
    while curr <= end:
        curr += delta 
        array = np.append(array, curr)
    return(array)
    

def gen_clustersDF(dates, ndvi_clust, iterdDBA):
    '''
    Generates a pd.DataFrame with the values of the iterated DTW Barycenter Averaging per cluster
    INPUT:
        - dates: array ('datetime64[D]') with observation dates of the NDVI values
        - ndvi_clust: pickle with the clusters value on the municipality
        - iterdDBA: picke with the value of the iterated DBA over the pixels belonging to each cluster
    OUTPUT:
        - ndvi_df: (pd.DataFrame) values of the NDVI averaged by cluster. 
                  Columns named 'cNUMBER' for cluster values and "indNUMBER" for single element clusters
    '''
    ndvi_df = pd.DataFrame(dates , columns = ['dates'])
    for clust in range(1,np.max(ndvi_clust)+1):
        cloc = np.where(ndvi_clust == clust)
        name = 0 
        if clust < np.max(ndvi_clust):
            name = 'c'+str(clust)
            ndvi_df[name] = iterdDBA[cloc[0][0],cloc[1][0]]
        else:
            for x,y in zip(cloc[0],cloc[1]):
                name += 1 
                ndvi_df['ind'+str(name)] = iterdDBA[x,y]
    return ndvi_df.set_index('dates')

    
def minVal(v1, v2, v3):
    '''
    #===============================================================================
    # function to return the min of of 3 vectors based on the first entry comparison
    #===============================================================================
    '''
    if v1[0] <= np.min([v2[0], v3[0]]):
        return v1
    else:
        if v2[0] <= v3[0]:
            return v2
        else:
            return v3

def DTW(A,B):
    '''
    #=====================================================================================================
    # function to return  the Dynamic Time Warp in a 3 dimensional array m_TS
    #   input: A, B - time series in 2 dimensions
    #
    #   output: m_TS - 3-dimensional array of (distance to reach that node, path(x_coord), path(y_coord) )
    #
    # REFERENCE: to ALGORITHM 1 from:
    #           Petitjean, et.al (2011), A global averaging method for dynamic time warping, with applications to clustering
    #
    #=====================================================================================================

    # ======================================================
    # ========= generate sample data  ======================
    # ======================================================
    t = 5 # sample rate = 100
    waves = 1 # frequency of the singal
    x = np.arange(0, 2*math.pi*waves,2*math.pi*(1/t))
    alpha = math.pi*0.25
    A = [math.cos(i) for i in x]
    plt.plot(x, A, label = 'cos(t)')
    B = [math.cos(i +alpha) for i in x]
    plt.plot(x, B, label='cos(t+alpha)')
    C = [i +alpha*1.5 for i in B]
    plt.plot(x, C, label='cos(t+alpha)+alpha')
    plt.legend()
    plt.show()
    # ============================================================
    '''
    S = len(A)
    T = len(B)
    m_ST = np.ones([S, T, 3])  # matrix of couples (cost,path)
    # compute 1st entrance:
    m_ST[0, 0, 0] = np.abs(A[0] - B[0])  # probar con np.abs(a ver si es más rápido)
    m_ST[0, 0, 1:3] = [0, 0]  # the path from 1st node is (0,0)

    #  fill first row
    for i in range(1, S):
        m_ST[i, 0, 0] = np.abs(A[i] - B[0]) + m_ST[i-1, 0, 0]
        m_ST[i, 0, 1:3] = [i-1, 0]
    #  fill first column
    for j in range(1, T):
        m_ST[0, j, 0] = np.abs(A[0] - B[j]) + m_ST[0, j-1, 0]
        m_ST[0, j, 1:3] = [0, j-1]

    for i in range(1, S):
        for j in range(1, T):
            minimum = minVal(m_ST[i-1, j], m_ST[i, j-1], m_ST[i-1, j-1])
            m_ST[i, j, 0] = minimum[0] + np.abs(A[i]-B[j])
            m_ST[i, j, 1:3] = minimum[1:3]

    return m_ST


def DBA (C,S):
    ''' Function to compute the DTW Barycenter Averaging. fastdtw required

    Parameters:
        C - List containing initial series of averages.
        S - List of lists containing the set of series to average
            S = [S_1, S_2, .. , S_n ]; and Si = [s_i1, ..., s_in_i]

    Output:
        Cprime - Computed list containing the new average using the DBA algorithm.

    REFERENCE: ALGORITHM 5 from:
               Petitjean, et.al (2011), A global averaging method for dynamic time warping, with applications to clustering
    '''
    T = len(S[0])
    Tprime = len(C)
    assoctab = [[] for k in range(Tprime)]
    for seq in range(0, len(S)):
        dist, path = dtw.fastdtw(C, S[seq], radius=len(S[seq]))
        lon = len(path) - 1
        while lon >= -1:  #  i > -1 and j > -1):
            assoctab[path[lon][0]].append(S[seq][path[lon][1]])
            lon = lon - 1

    Cprime = np.zeros(C.shape)
    for i in range(0,T):
        Cprime[i] = np.mean(assoctab[i])  # for the author of the article the barycenter is the arithmetic mean.
    return Cprime



def gen_clusterTS(imageTS, clusterMap):
    '''Function to generate a Time Series (TS) for each cluster in clusterMap.
    The information of each TS in the imageTS is aggregated by DTW Baricenter Averaging (DBA). 
   
    Parameters:
       imageTS    - 3-dimensional array containing the observed values of the NDVI/EVI in a
                    geographical area over time.
       clusterMap - 2-dimensional array containing the cluster where each pixel belongs
                    in the delimited geographical area (same as imageTS)

    Output:
        3 different outputs are possible. They all contain the aggregated-by-cluster information
        of the NDVI/EVI time series of imageTS.
        clust_meanTS      - information aggregated by the mean over the x-axis.
        clust_DBA         - information aggregated by the DBA.
        clust_DBAiterated - information aggregated by the iterated DBA

    '''
    clust_meanTS = np.zeros(imageTS.shape) # new Time Series (TS) will be here.
    clust_DBA = np.zeros(imageTS.shape) # new TS will be here.
    clust_DBAiterated = np.zeros(imageTS.shape)  # new TS will be here
    for c in range(1,np.max(clusterMap)):
        cloc = np.where(clusterMap == c)
        C = np.zeros(imageTS[cloc][0].shape)
        dba = DBA(C,imageTS[cloc]) # arithmetic mean of the series in imageTS[loc] of point associations over the point in C
        media = np.mean(imageTS[cloc], axis=0)  # arithmetic mean point by point over the x-axis
        dba_iterated = dba.copy()
        dba_prev = np.zeros(dba_iterated.shape)
        it = 1
        while sum(abs(dba_iterated - dba_prev)) > 0:
            dba_prev = dba_iterated.copy()
            dba_iterated = DBA(dba, imageTS[cloc])
            it = it + 1
        # generate the TS to visualize the municipality map
        clust_DBA[cloc] = dba.copy()
        clust_DBAiterated[cloc] = dba_iterated.copy()
        clust_meanTS[cloc] = media.copy()
        # plotting part of the routine. UNCOMMENT if needed
        ''''
        plt.figure()
        plt.plot(dba, label = 'DBA-1')
        plt.plot(media, '--', label = 'x-axis mean')
        for j in  range(len(imageTS[cloc])):
            plt.plot(imageTS[cloc][j], '--', alpha=0.3, label='clusterMap' + str(c)+' j'+str(j))
        plt.plot(dba_iterated, label='DBA-iterated')
        plt.legend()
        '''
    #  locate the clusters with a single pixel in them
    cloc = np.where(clusterMap == np.max(clusterMap))
    clust_DBA[cloc] = imageTS[cloc]
    clust_DBAiterated[cloc] = imageTS[cloc]
    clust_meanTS[cloc] = imageTS[cloc]
    return (clust_meanTS, clust_DBA, clust_DBAiterated)


''' ------------------------------------------------------------------------------'''